{"version":3,"sources":["vertices.js","shaders/borders.frag","shaders/borders.vert","shaders/texture.frag","shaders/texture.vert","main.js"],"names":["compute_borders","buffer","count","Uint32Array","indices","coords","Float32Array","length","vertices","v","i","len","a","j","b","push","module","exports","regl","getBorders","fetch","borderData","then","response","arrayBuffer","getTexture","filename","Promise","resolve","image","Image","src","crossOrigin","onload","texture","data","flipY","longitude_offset","prop","createLineDrawer","frag","bordersFrag","vert","bordersVert","uniforms","aspectRatio","blend","enable","func","dst","depth","attributes","position","primitive","main","borders","landTexture","monoTexture","all","specImg","monoImg","drawBorders","drawTexture","textureFrag","textureVert","frame","time","viewportWidth","viewportHeight","ar","catch","console","error"],"mappings":"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","file":"main.a29df9f9.js","sourceRoot":"..","sourcesContent":["export function compute_borders(buffer) {\n  // First uint32 (4 bytes) contain the number of line strings.\n  const count = new Uint32Array(buffer, 0, 1)[0];\n  // Each of the next `count` uint32s stores the vertex count of a line string.\n  const indices = new Uint32Array(buffer, 4, count);\n  // Rest of bytes contain vertex coordinates (alternating long-lat pairs)\n  const coords = new Float32Array(buffer, 4 * (indices.length + 1));\n\n  const vertices = [];\n  let v = 0;\n\n  for (let i = 0; i < indices.length; i += 1) {\n    const len = indices[i];\n\n    let a = [coords[v++], coords[v++]];\n\n    for (let j = 1; j < len; j += 1) {\n      const b = [coords[v++], coords[v++]];\n\n      vertices.push(...a, ...b);\n\n      a = b;\n    }\n  }\n\n  return new Float32Array(vertices);\n}\n","module.exports=\"precision mediump float;\\n#define GLSLIFY 1\\n\\nvarying float v_depth;\\n\\nvoid main() {\\n  // Discard when depth is negative, whether interpolated or not.\\n  if (v_depth < 0.) {\\n    discard;\\n  }\\n\\n  gl_FragColor = vec4(vec3(230. / 255.), 1.);\\n}\\n\";","module.exports=\"#define PI 3.1415926538\\n\\nvec3 project(vec2 point, float longitude_offset) {\\n  point *= PI / 180.;\\n  float lon = point[0];\\n  float lat = point[1];\\n\\n  float azimuth = lon - longitude_offset;\\n  float inclination = PI / 2. - lat;\\n\\n  float depth = sin(inclination) * cos(azimuth);\\n  float x = sin(inclination) * sin(azimuth);\\n  float y = cos(inclination);\\n\\n  return vec3(x, y, depth);\\n}\\n\\nprecision mediump float;\\n#define GLSLIFY 1\\n\\nuniform vec2 aspectRatio;\\nuniform float longitude_offset;\\n\\nattribute vec2 position;\\n\\nvarying float v_depth;\\n\\nvoid main() {\\n  vec3 projected_position = project(position, longitude_offset);\\n\\n  v_depth = projected_position.z;\\n\\n  gl_Position = vec4(projected_position.xy / aspectRatio, 0, 1);\\n}\\n\";","module.exports=\"#define PI 3.1415926538\\n\\nprecision mediump float;\\n#define GLSLIFY 1\\n\\nuniform sampler2D landTexture;\\nuniform sampler2D monoTexture;\\n\\nuniform float longitude_offset;\\n\\nvec3 light_reversed = vec3(-0.5, 0.5, 0.3);\\nfloat light_mag = length(light_reversed);\\n\\nvarying vec2 v_position;\\n\\nvoid main() {\\n\\n  // The screen is the tangent plane. Each (x, y) we treat as an\\n  // orthographically projected point of the front-facing hemisphere.\\n  // The textures are equirectangular projections, which means the position of\\n  // an image pixel is just the longitude-latitude.\\n  // For each fragment, then, we must figure out the corresponding lat-long to\\n  // retrieve the correct image pixel.\\n\\n  // 1. Define the projected coordinates.\\n  //    Discard fragments outside the great circle.\\n\\n  float x = v_position.x;\\n  float y = v_position.y;\\n  float c = x * x + y * y; // Distance from center of orthographic projection\\n\\n  if (sqrt(c) > 1.) {\\n    discard;\\n  }\\n\\n  // 2. Invert projection to get spherical coordinates\\n\\n  float depth = sqrt(1. - c); // Purposefully ignoring negative face\\n  float longitude = atan(x / depth) + longitude_offset; // [-PI / 2, PI / 2]\\n  float latitude = asin(y);                             // [-PI / 2, PI / 2]\\n\\n  // 3. Do equirectangular projection to get plane/texture coordinates\\n  //    For longitude: Map to [0.25, 0.75] (center is 0.5, range is 0.5)\\n  //    For latitude: Map to [0, 1] (center is 0.5, range is 0.5)\\n\\n  float texture_x = (longitude + PI) / (2. * PI);\\n  float texture_y = (latitude + PI / 2.) / PI;\\n\\n  // 4. Grab texture colors. Black = land, white = no land.\\n\\n  vec2 texture_position = vec2(mod(texture_x, 1.0), texture_y);\\n  vec3 texture_color = texture2D(landTexture, texture_position).rgb;\\n  vec3 mono_color = texture2D(monoTexture, texture_position).rgb;\\n\\n  texture_color += mono_color;\\n\\n  // 5. Calculate lighting.\\n\\n  float dotted = dot(vec3(x, y, depth), light_reversed) / light_mag;\\n  float light = sign(dotted) * pow(abs(dotted), 1.7);\\n  light = 0.6 + light * 0.37;\\n\\n  // gl_FragColor = vec4(texture_color, 1.);\\n  gl_FragColor = vec4(texture_color, 1.);\\n  gl_FragColor.rgb *= light;\\n}\\n\";","module.exports=\"precision mediump float;\\n#define GLSLIFY 1\\n\\nuniform vec2 aspectRatio;\\n\\nattribute vec2 position;\\n\\nvarying vec2 v_position;\\n\\nvoid main() {\\n  // For some reason textures only cover the first quadrant of the clip space.\\n  // Remember that v_position should become the coordinate of the texture in\\n  // clip space. Cutting position in half means that (1, 1) in the clip space\\n  // becomes (0.5, 0.5) on the texture.\\n  // two quadrants' worth of space.\\n  // Adding 0.5 to position means that (1, 1) in the clip space becomes (1, 1)\\n  // on the texture, and similarly (0, 0) -> (0.5, 0.5) (the texture's center)\\n  // and (-1, -1) -> (0, 0).\\n\\n  // v_position = 0.5 + position * 0.5;\\n  v_position = position * aspectRatio;\\n\\n  // gl_Position should be position because the position attribute covers the\\n  // whole clip space\\n  gl_Position = vec4(position, 0, 1);\\n}\\n\";","import createREGL from 'regl';\nimport { compute_borders } from './vertices';\n\nimport bordersFrag from './shaders/borders.frag';\nimport bordersVert from './shaders/borders.vert';\nimport textureFrag from './shaders/texture.frag';\nimport textureVert from './shaders/texture.vert';\n\nimport specImg from './specularity@2x.png';\nimport monoImg from './mono@2x.png';\n\nimport borderData from './borders.dat';\n\nconst regl = createREGL();\n\nasync function getBorders() {\n  return fetch(`./${borderData}`)\n    .then(response => response.arrayBuffer())\n    .then(buffer => compute_borders(buffer));\n}\n\nasync function getTexture(filename) {\n  return new Promise(resolve => {\n    const image = new Image();\n    image.src = filename; // `${base}/textures/${filename}`;\n    image.crossOrigin = '';\n    image.onload = () => resolve(regl.texture({ data: image, flipY: true }));\n  });\n}\n\nconst longitude_offset = regl.prop('longitude_offset');\n\nfunction createLineDrawer(vertices) {\n  return regl({\n    frag: bordersFrag,\n    vert: bordersVert,\n\n    uniforms: {\n      aspectRatio,\n      longitude_offset,\n    },\n\n    blend: {\n      enable: true,\n      func: {\n        src: 'src alpha',\n        dst: 'one minus src alpha',\n      },\n    },\n    depth: { enable: false },\n    attributes: { position: vertices },\n\n    count: vertices.length / 2,\n    primitive: 'lines',\n  });\n}\n\nasync function main() {\n  const [\n    borders,\n    landTexture,\n    monoTexture,\n  ] = await Promise.all([\n    getBorders(),\n    getTexture(specImg),\n    getTexture(monoImg),\n  ]);\n\n  const drawBorders = createLineDrawer(borders);\n\n  const drawTexture = regl({\n    frag: textureFrag,\n    vert: textureVert,\n\n    uniforms: {\n      landTexture,\n      monoTexture,\n      aspectRatio,\n      longitude_offset,\n    },\n\n    attributes: {\n      // Two triangles that cover the whole clip space\n      position: regl.buffer([\n        [-1, 1],\n        [1, -1],\n        [1, 1],\n        [-1, 1],\n        [1, -1],\n        [-1, -1],\n      ]),\n    },\n\n    count: 6,\n  });\n\n  regl.frame(({ time }) => {\n    const longitude_offset = time / 10;\n\n    drawTexture({ longitude_offset });\n    drawBorders({ longitude_offset });\n  });\n}\n\nmain().catch(console.error);\n\nfunction aspectRatio({ viewportWidth, viewportHeight }) {\n  const ar = viewportWidth / viewportHeight;\n  return ar > 1 ? [ar, 1] : [1, 1 / ar];\n}\n"]}